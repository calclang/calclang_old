package thosakwe.calclang.calc2c;


import org.antlr.v4.runtime.ANTLRFileStream;
import org.antlr.v4.runtime.ANTLRInputStream;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.Token;
import org.antlr.v4.runtime.tree.TerminalNode;
import org.apache.commons.cli.CommandLine;
import thosakwe.calclang.CalcLangTarget;
import thosakwe.calclang.antlr.CalcLangLexer;
import thosakwe.calclang.antlr.CalcLangParser;
import thosakwe.calclang.vm.CalcLangInterpreter;

import java.io.File;
import java.io.IOException;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.List;

public class CTranspiler extends CalcLangTarget {
    // This guy can help us out a lot at compile time.
    CalcLangInterpreter interpreter;
    List<String> currentNames = new ArrayList<>();
    int tabs = 0;

    public CTranspiler(PrintStream output, CommandLine options) {
        super(output, options);
        interpreter = new CalcLangInterpreter(output, options);
        interpreter.silent = true;
    }

    void insertTabs() {
        for (int i = 0; i < tabs; i++)
            output.print("    ");
    }

    void print(String code) {
        output.println(code);
    }

    @Override
    public Object visitAssignstmt(CalcLangParser.AssignstmtContext ctx) {
        insertTabs();
        String assigner = currentNames.contains(ctx.ID().getText()) ? "" : "double ";

        if (ctx.expr().function != null) {
            output.print(assigner + ctx.ID().getText() + " = " + ctx.expr().function.getText() + "(");
            for (int i = 0; i < ctx.expr().expr().size(); i++) {
                if (i > 0)
                    output.print(", ");
                output.print(interpreter.visitExpr(ctx.expr().expr(i)));
            }
            output.print(")");
            print(";");
            return null;
        }

        Double result = interpreter.visitAssignstmt(ctx);
        print(assigner + ctx.ID().getText() + " = " + result.toString() + ";");
        if (!currentNames.contains(ctx.ID().getText()))
            currentNames.add(ctx.ID().getText());
        return null;
    }

    @Override
    public Object visitBlock(CalcLangParser.BlockContext ctx) {
        tabs++;
        Object result = super.visitBlock(ctx);
        currentNames.clear();
        tabs--;
        return result;
    }

    @Override
    public Object visitCompilationUnit(CalcLangParser.CompilationUnitContext ctx) {
        print("// Generated by CalcLang\n");
        print("#include <stdio.h>\n");
        interpreter.currentScript = ctx;
        interpreter.currentBlock = currentBlock;
        interpreter.visitCompilationUnit(ctx);
        //constants.putAll(interpreter.constants);
        return super.visitCompilationUnit(ctx);
    }

    @Override
    public Object visitExpr(CalcLangParser.ExprContext ctx) {
        return interpreter.visitExpr(ctx);
    }

    @Override
    public Object visitFnblock(CalcLangParser.FnblockContext ctx) {
        if (ctx.name.getText().equals("main"))
            output.print("int main(");
        else
            output.print("double " + ctx.name.getText() + " (");
        for (int i = 0; i < ctx.params().ID().size(); i++) {
            if (i > 0)
                output.print(", ");
            output.print(ctx.params().ID(i).getText());
        }
        print(") {");
        Object result = super.visitFnblock(ctx);
        print("}");
        return result;
    }

    @Override
    public Object visitImportstmt(CalcLangParser.ImportstmtContext ctx) {
        CalcLangParser.CompilationUnitContext oldScript = currentScript;
        String path = ctx.STRING().getText().replaceAll("(^\")|(\"$)", "");
        File file = new File(options.getOptionValue("in", "."));
        String absolute = file.toPath().resolveSibling(".").resolve(path).toAbsolutePath().toString();
        try {
            ANTLRInputStream antlrInputStream = new ANTLRFileStream(absolute);
            CalcLangLexer lexer = new CalcLangLexer(antlrInputStream);
            CommonTokenStream tokens = new CommonTokenStream(lexer);
            CalcLangParser parser = new CalcLangParser(tokens);
            parser.setBuildParseTree(true);
            CalcLangParser.CompilationUnitContext program = parser.compilationUnit();
            visitCompilationUnit(program);
            for (String key : program.functions.keySet()) {
                // Import all functions
                oldScript.functions.put(key, program.functions.get(key));
            }
            for (String key : program.globals.keySet()) {
                // ... And globals
                oldScript.globals.put(key, program.globals.get(key));
            }
            currentScript = oldScript;
            return null;
        } catch (IOException e) {
            System.err.println("Could not open file \"" + absolute + "\".");
            return null;
        }
    }

    @Override
    public Object visitPrintstmt(CalcLangParser.PrintstmtContext ctx) {
        return null;
    }

    @Override
    public Object visitReturnstmt(CalcLangParser.ReturnstmtContext ctx) {
        insertTabs();
        Double result = interpreter.visitExpr(ctx.expr());
        if (((CalcLangParser.FnblockContext) currentBlock.getChild(0)).name.getText().equals("main")) {
            print("return " + result.intValue() + ";");
            return null;
        }
        print("return " + result + ";");
        return null;
    }
}
